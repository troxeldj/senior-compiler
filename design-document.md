## User Stories
1. As a user, I want my source code to compile into x86/x64 assembly so that I can link, load, and execute my code.
- This is a broad requirement. The goal of this compiler is to take source code in our language and produce something that can be ran on a machine.
2. As a user, I want the compiler to generate detailed error messages so that I can easily debug issues with my code.
- This requirement pertains to error messages raised throughout the stages in the compiler. The compiler should be able to tell the user where the error was so that they can easier locate the error in their code and make the appropriate fix.
3. As a developer, I want the the compiler to handle variable declarations so that users can perform operations on variable data.
- This requirement will allow users to create variables of a specified type. This is an important feature of any language.

## Design 1 - Compiler Function

[Design Link](https://github.com/troxeldj/senior-compiler/blob/master/design-diagrams/design-1.png)

The first diagram is simple, but it's important to understand exactly what a compiler does. A compiler is defined as a program that takes in code in a "source" language (often called source code), and generates code in another (target) language.

This simple succinctly diagram defines this operation. The next diagrams will get deeper into how exactly this translation occurs.

## Design 2 - Compiler Stages

[Design Link](https://github.com/troxeldj/senior-compiler/blob/master/design-diagrams/design-2.png)

This diagram goes further into how this process will look by breaking it up into stages.

These stages are as follows:
- **Lexical Analysis**: Here we scan through characters, group them and output Tokens. A token is a data structure that contains a value and a type (see diagram 3 for more detail).
	- Input: text (file contents)
	- Output: A list of tokens
- **Syntax Analysis**: Here we work with the tokens output by the lexer. We define a grammar and can build a parser to parse tokens according to our grammar (the starting grammar is defined below)
	- Input: List of Tokens
	- Output: AST (Abstract Syntax Tree)
	- Note: Our language will use a "Recursive Descent Parser"
- **Intermediate Code Generation (optional)**: During the transition from source code to target code, a compiler might generate a variety of intermediate representations of our program before eventually getting to our target code.
	- Input: AST (Abstract Syntax Tree) or Another Intermediate Representation of our AST
	- Output: Intemediate representation of our program
- **Code Generation**: Here is where we use our Abstract Syntax Tree or intermediate representation to generate code in our target language
	- Input: AST or intermediate representation of our program
	- Output: Code in our target language
## Design 3 - UML Diagram

[Design Link](https://github.com/troxeldj/senior-compiler/blob/master/design-diagrams/design-3.png)

This more-in-depth design goes into the system at a component level. We define classes used by the various stages

Compiler Components:
- **Lexer**: The lexer will take in source code, group characters into "lexemes" and make tokens out of these lexemes and a token type. 
- **Parser**: The parser will take the list of tokens from the lexer, fit them to a grammar (starting grammar provided - will expand as project goes on).
-  **Generator**: The generator will take the AST generated by the parser,  run the generateProgram method that will traverse this tree, and generate code for the elements in the tree. The generator will produce assembly code that we can then link, load, and execute on our machine.

Other Classes: 
- **TokenType (enum)**: This enum will hold all the token types for the language. The token has a token type that allows the developer to differentiate between tokens based on their type.
- **Token**: This class will be used in the lexer to generate a list of tokens based on input text. It will also be used by the parser to tell what operations are occuring (example: \<number\> \<operator\> \<number\> is a binary operation).
- **Expr**: Base class for expressions. This abstract class will serve as a base class for other expression types (such as BinaryExpr, UnaryExpr, Literal)